generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("DATABASE_URL")
    directUrl = env("DIRECT_URL")
}

//////////////////////////////////////
// Enums
//////////////////////////////////////

enum Role {
    ADMIN
    MANAGER
    STAFF
    VIEWER
}

enum PartnerType {
    SUPPLIER
    CUSTOMER
}

enum DocumentType {
    IN
    OUT
    TRANSFER
}

enum DocumentStatus {
    DRAFT
    POSTED
    CANCELLED
}

//////////////////////////////////////
// Core / Identity
//////////////////////////////////////

model User {
    id           String   @id @default(uuid())
    email        String   @unique
    passwordHash String
    displayName  String
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    roles     UserRole[]
    documents Document[] @relation("DocumentCreatedBy")
    auditLogs AuditLog[]
}

model RoleEntity {
    id    String     @id @default(uuid())
    name  Role       @unique
    users UserRole[]
}

model UserRole {
    id     String @id @default(uuid())
    userId String
    roleId String

    user User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    role RoleEntity @relation(fields: [roleId], references: [id], onDelete: Cascade)

    @@unique([userId, roleId])
}

//////////////////////////////////////
// Master data
//////////////////////////////////////

model Warehouse {
    id        String   @id @default(uuid())
    code      String   @unique
    name      String
    address   String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    locations Location[]
    docsFrom  Document[]    @relation("DocFromWarehouse")
    docsTo    Document[]    @relation("DocToWarehouse")
    ledgers   StockLedger[]
}

model Location {
    id          String   @id @default(uuid())
    warehouseId String
    code        String
    name        String?
    description String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)

    // Document lines may refer to from/to location (for TRANSFER)
    linesFrom DocumentLine[] @relation("LineFromLocation")
    linesTo   DocumentLine[] @relation("LineToLocation")

    ledgers StockLedger[]

    @@unique([warehouseId, code]) // code unique trong từng kho
}

model Category {
    id        String   @id @default(uuid())
    name      String
    parentId  String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    parent   Category?  @relation("CategoryToSelf", fields: [parentId], references: [id])
    children Category[] @relation("CategoryToSelf")

    products Product[]
}

model Unit {
    id        String   @id @default(uuid())
    code      String   @unique // VD: PCS, BOX, KG
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    products Product[]
}

model Product {
    id           String   @id @default(uuid())
    sku          String   @unique
    name         String
    barcode      String?  @unique
    categoryId   String?
    unitId       String
    costPrice    Decimal? @db.Decimal(18, 2) // giá nhập tham chiếu
    salePrice    Decimal? @db.Decimal(18, 2) // giá bán tham chiếu
    reorderLevel Decimal? @db.Decimal(18, 3)
    isActive     Boolean  @default(true)
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    category Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
    unit     Unit      @relation(fields: [unitId], references: [id])

    lines   DocumentLine[]
    ledgers StockLedger[]

    @@index([name])
    @@index([sku])
    @@index([barcode])
}

model Partner {
    id        String      @id @default(uuid())
    type      PartnerType
    code      String      @unique
    name      String
    phone     String?
    email     String?
    address   String?
    createdAt DateTime    @default(now())
    updatedAt DateTime    @updatedAt

    documents Document[]
}

//////////////////////////////////////
// Documents (IN/OUT/TRANSFER)
//////////////////////////////////////

model Document {
    id     String         @id @default(uuid())
    code   String         @unique // số phiếu
    type   DocumentType
    status DocumentStatus @default(DRAFT)

    // Kho tham chiếu (tùy loại phiếu)
    warehouseFromId String?
    warehouseToId   String?

    partnerId   String? // supplier cho IN, customer cho OUT
    createdById String

    note      String?
    postedAt  DateTime? // lúc ghi sổ
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    warehouseFrom Warehouse? @relation("DocFromWarehouse", fields: [warehouseFromId], references: [id], onDelete: SetNull)
    warehouseTo   Warehouse? @relation("DocToWarehouse", fields: [warehouseToId], references: [id], onDelete: SetNull)
    partner       Partner?   @relation(fields: [partnerId], references: [id], onDelete: SetNull)
    createdBy     User       @relation("DocumentCreatedBy", fields: [createdById], references: [id])

    lines   DocumentLine[]
    ledgers StockLedger[]
}

model DocumentLine {
    id             String   @id @default(uuid())
    documentId     String
    productId      String
    qty            Decimal  @db.Decimal(18, 3)
    unitPrice      Decimal? @db.Decimal(18, 2) // optional: theo phiếu
    // Vị trí kệ/ngăn: với TRANSFER có thể dùng cả from/to
    locationFromId String?
    locationToId   String?

    note      String?
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    document     Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
    product      Product   @relation(fields: [productId], references: [id])
    locationFrom Location? @relation("LineFromLocation", fields: [locationFromId], references: [id], onDelete: SetNull)
    locationTo   Location? @relation("LineToLocation", fields: [locationToId], references: [id], onDelete: SetNull)

    ledgers StockLedger[]

    @@index([documentId])
    @@index([productId])
}

//////////////////////////////////////
// Stock Ledger (single source of truth for qty)
//////////////////////////////////////

model StockLedger {
    id          String  @id @default(uuid())
    productId   String
    warehouseId String
    locationId  String?
    documentId  String?
    lineId      String?

    qtyDelta  Decimal  @db.Decimal(18, 3) // +IN, -OUT
    createdAt DateTime @default(now())

    product   Product       @relation(fields: [productId], references: [id])
    warehouse Warehouse     @relation(fields: [warehouseId], references: [id])
    location  Location?     @relation(fields: [locationId], references: [id], onDelete: SetNull)
    document  Document?     @relation(fields: [documentId], references: [id], onDelete: SetNull)
    line      DocumentLine? @relation(fields: [lineId], references: [id], onDelete: SetNull)

    @@index([productId, warehouseId])
    @@index([productId, warehouseId, locationId])
    @@index([documentId])
    @@index([createdAt])
}

//////////////////////////////////////
// Operational extras
//////////////////////////////////////

model IdempotencyKey {
    id        String   @id @default(uuid())
    key       String
    purpose   String // e.g. "CREATE_DOCUMENT"
    createdAt DateTime @default(now())

    // đảm bảo 1 key chỉ dùng một lần cho cùng purpose
    @@unique([key, purpose])
}

model AuditLog {
    id        String   @id @default(uuid())
    userId    String?
    action    String // e.g. "DOCUMENT.POSTED"
    entity    String // e.g. "Document"
    entityId  String // target id
    diff      Json?
    createdAt DateTime @default(now())

    user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

    @@index([entity, entityId])
}
